<!DOCTYPE html>
<html>
  <head>
    <title>WebGL2 Dual-Buffer Transform Feedback PBO</title>
    <style>
      canvas {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <h1>WebGL2 Dual-Buffer Transform Feedback Pixel Buffer Object</h1>
    <p>
      Github:
      <a href="https://github.com/RenaudRohlinger/webgl-compute-pbo"
        >https://github.com/RenaudRohlinger/webgl-compute-pbo</a
      >
    </p>
    <p>
      This example showcases a technique similar to compute shading using
      dual-buffer transform feedback and a Pixel Buffer Object (PBO) to simulate
      compute shader effects in environments where they are not available.
      <br />
      Every second, a 'compute' operation processes vertex data through
      transform feedback in a ping-pong manner between two buffers. The results,
      stored in an array buffer, are then transferred to a texture using a PBO
      (gl.PIXEL_UNPACK_BUFFER), which keeps the processed data entirely on the
      GPU for enhanced performance.
    </p>
    <p>
      Shaders can access the updated data in the texture through a texture
      uniform, allowing for efficient data manipulation and comparison using
      texelFetch. This approach minimizes CPU-GPU data transfer, optimizing
      performance for GPU-based computations like dynamic sorting or
      simulations.
    </p>
    <p>
      The compute operation in this example incrementally updates vertex data
      values, transferring them to a texture using a GPU-to-GPU Pixel Buffer
      Object (PBO) transfer. This method avoids CPU involvement, improving
      performance. For debugging, the texture's contents are read back to the
      CPU using gl.readPixels.
    </p>
    <hr />
    <code id="debug">Pixel Buffer Object Data:</code>
    <br />
    <br />
    <i>Normalized [0 - 10] [black - red] values of the texture are displayed</i>
    <canvas id="glcanvas"></canvas>
    <br />
    <br />
    <br />

    <p>Code:</p>
    <pre
      style="
        background-color: #f5f5f5;
        border: 1px solid #ddd;
        font-size: 14px;
        word-break: break-all;
        word-wrap: break-word;
        font-family: monospace;
        color: #333;
        padding: 10px;
        line-height: 1.5;
      ">
&lt;!-- Path: ./index.js --&gt;
&lt;script&gt;
const canvas = document.getElementById('glcanvas');
const gl = canvas.getContext('webgl2');


class DualAttributeData {
    constructor(buffer, dualBuffer) {
        this.buffers = [buffer, dualBuffer];
        this.textures = [gl.createTexture(), gl.createTexture()];
        this.activeBufferIndex = 0;
    }

    get buffer() {
        return this.buffers[this.activeBufferIndex];
    }

    get transformBuffer() {
        return this.buffers[this.activeBufferIndex ^ 1];
    }

    get texture() {
        return this.textures[this.activeBufferIndex];
    }

    get transformTexture() {
        return this.textures[this.activeBufferIndex ^ 1];
    }

    switchBuffers() {
        this.activeBufferIndex ^= 1;
    }
}

// Updated vertex shader for transform feedback
const vsTransform = `#version 300 es
in vec4 a_data;
out vec4 o_data;

void main() {
    o_data = mod(a_data + 1., 10.);
}`;

// Fragment shader for transform feedback (not used but required)
const fsTransform = `#version 300 es
precision highp float;
void main() {
}`;

// Create shaders and programs
const transformProgram = createProgram(gl, vsTransform, fsTransform, [
'o_data',
]); // Add the varyings parameter

const size = 2;
const dataArray = new Float32Array(size * 4);
dataArray
.map((_, i) => i)
.forEach((v, i) => {
    dataArray[i] = v;
});

const width = size;
const height = 1;

const datas = new Float32Array(dataArray);

const readBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, readBuffer);
gl.bufferData(gl.ARRAY_BUFFER, datas, gl.STATIC_DRAW);

const writeBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, writeBuffer);
gl.bufferData(gl.ARRAY_BUFFER, datas.byteLength, gl.DYNAMIC_COPY);

const attributeData = new DualAttributeData(readBuffer, writeBuffer);

// Setup transform feedback
const tf = gl.createTransformFeedback();
gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf);
gl.bindBufferBase(
gl.TRANSFORM_FEEDBACK_BUFFER,
0,
attributeData.transformBuffer
);

// Create and bind texture
for (let i = 0; i < 2; i++) {
  gl.bindTexture(gl.TEXTURE_2D, attributeData.textures[i]);
  gl.texImage2D(
    gl.TEXTURE_2D,
    0,
    gl.RGBA32F,
    width,
    height,
    0,
    gl.RGBA,
    gl.FLOAT,
    null
  );
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
}

// Create a framebuffer
const framebuffer = gl.createFramebuffer();
gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);

// Attach the texture to the framebuffer
gl.framebufferTexture2D(
  gl.FRAMEBUFFER,
  gl.COLOR_ATTACHMENT0,
  gl.TEXTURE_2D,
  attributeData.texture,
  0
);

// Create a framebuffer
const framebuffer = gl.createFramebuffer();
gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);

// Attach the texture to the framebuffer
gl.framebufferTexture2D(
gl.FRAMEBUFFER,
gl.COLOR_ATTACHMENT0,
gl.TEXTURE_2D,
texture,
0
);

const dataLocation = gl.getAttribLocation(transformProgram, 'a_data');

const drawDataLocation = gl.getAttribLocation(drawProgram, 'a_data');

function tick() {
// Bind the read buffer for input
gl.bindBuffer(gl.ARRAY_BUFFER, attributeData.bufferGPU);
gl.enableVertexAttribArray(dataLocation);
gl.vertexAttribPointer(dataLocation, 4, gl.FLOAT, false, 0, 0);

// Use the transform program
gl.useProgram(transformProgram);

// Set the write buffer as the transform feedback buffer
gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf);
gl.bindBufferBase(
    gl.TRANSFORM_FEEDBACK_BUFFER,
    0,
    attributeData.transformBuffer
);

// Perform transform feedback
gl.enable(gl.RASTERIZER_DISCARD);
gl.beginTransformFeedback(gl.POINTS);
gl.drawArrays(gl.POINTS, 0, width); // Adjust the count as needed
gl.endTransformFeedback();
gl.disable(gl.RASTERIZER_DISCARD);

gl.bindBuffer(gl.ARRAY_BUFFER, null);
gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);

gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);

// Bind PBO and transfer data to texture
gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, attributeData.buffer);
// Add double buffer texture to prevent stalling on read
gl.bindTexture(gl.TEXTURE_2D, attributeData.texture);
gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, gl.RGBA, gl.FLOAT, 0);
gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, null);

// Ping-pong: swap the read and write buffers
attributeData.switchBuffers();
debug();
}

setInterval(tick, 1000);

&lt;/script&gt;
</pre
    >

    <br />
    <br />
    <br />
    <p>
      Author: Renaud Rohlinger <a href="https://x.com/onirenaud">@onirenaud</a>
    </p>
    <script src="./index.js"></script>
  </body>
</html>
